## 分布式锁

锁, 本质上是一种处理抢占资源的机制，避免多线程下造成对共享资源的更新不一致的问题

分布式锁, 本质还是一种锁，起这个名字是为了便于描述这种锁的特点，针对分布式应用，进行锁控制的锁，就叫分布式锁

### 基于Redis实现的分布式锁

加锁操作：set lock:codehole true ex 5 nx

这个命令即setnx和expire组合在一起的原子命令，即分布式锁的奥义所在

基本解锁操作：del lock:codehole

#### redis的分布式锁不能解决超时问题

##### 案例：

1. A在0秒设置一个有效期为2秒的锁。 
2. 2.B在3秒时申请会拿到锁（因为A设置的锁已经过期） 
3.  A在4秒时，做完事情，以为锁还在自己手上，就去删除锁。 B拿到的锁会被A删掉。 这时候如果有C申请锁，B和C就会同时持有锁

##### 解决以上问题的初步办法：

1. 分布式锁不要用在较长时间的任务，避免遇到超时问题

2. 另稍微安全一点的方案：为 set 指令的 value 参数设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key，这是为了确保当前线程占有的锁不会被其它线程释放，除非这个锁是过期了被服务器自动释放的

3. 升级版解锁操作：即以上方案的应用，执行lua脚本来解锁。判断随机数是否匹配，匹配再执行删除操作。利用redis支持的lua脚本来确保这个操作的原子性。

### 基于ZooKeeper实现的分布式锁

使用**临时顺序节点**实现。

比如在`my_lock`这个锁节点下，创建临时顺序子节点，这个顺序节点有zk内部自行维护生成的一个节点序号。第一个创建的名字为：xxx-000001，第二个客户端再创建就是：xxx-000002。

#### 情形一：加锁成功

客户端A在`my_lock`这个锁节点下创建完临时顺序子节点后，再查一下`my_lock`下的所有子节点，查询结果集类似于这样：

```python
["xxx-000001"]
```

客户端A判断自己在`my_lock`这个锁节点下排在最前面（创建指令会返回成功创建的带编号的完整节点名称`xxx-000001`，拿这个名称比对即可判断），加锁成功。

#### 情形二：加锁失败

客户端B是第二个来创建临时顺序节点的，创建完后，查询`my_lock`下的所有子节点，查询结果集类似于这样：

```python
["xxx-000001", "xxx-000002"]
```

客户端B判断自己在`my_lock`这个锁节点下没排在最前面，加锁失败。然后对`my_lock`子节点的变化进行监听（Watch）。客户端A加锁之后，处理了一些代码逻辑，然后就会释放锁，即删除客户端A创建的临时顺序节点`my_lock/xxx-000001`。客户端B监听到后，重新尝试去获取锁，也就是查询`my_lock`下的所有子节点，查询结果集类似于这样：

```python
["xxx-000002"]
```

客户端B判断自己在`my_lock`这个锁节点下排在最前面，加锁成功。

#### 情形三：客户端宕机

无需处理，zk感知到那个客户端宕机，会自动删除对应的临时顺序节点，相当于自动释放锁。

### 实际代码操作

以上是分布式锁的核心原理，但如果要自己实现，还需要配合具体的线程锁操作和其他细节处理，还是直接用开源框架省事。