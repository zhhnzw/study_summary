## 并发模型

### 并发和并行的区别?
并发是**同时处理**多件事情，同一时间可以只做一件，而把其他任务做到一半先暂停，后续被暂停的任务再恢执行，这样来回切换达到并发处理多件事情的目的。并行是**同时做**多件事情，需要多核CPU支持。

### 进程、线程、协程的区别

**进程**：是系统资源分配的最小单位

**线程**：是CPU调度最小单位

**协程**：用户态轻量级线程，协程调度不需要内核参与而是由用户态程序来决定，协程对于操作系统而言是无感知的，协作式调度

* 进程之间是相互隔离的，各自拥有自己的内存空间
* 进程是线程的载体容器，进程内的多线程共享其内存空间，因此线程之间的通信比进程通信容易得多
* 虽然线程比较轻量，但是也有不小的调度开销，而多个goroutine可以运行在同一个线程之上，因此goroutine的调度减少了线程频繁切换的调度开销(go程序默认只使用与CPU数量相等的线程数量)

> Q: 用户态的协程如何适时的主动出让CPU控制权？

> A: goroutine控制器可能切换的点：
>
> 1. io，select关键字
> 2. channel
> 3. 等待锁
> 4. 函数调用(有时)
> 5. runtime.Gosched()

> Q: 协作式调度和抢占式调度的优缺点？

> A: 协作式调度可以降低线程切换开销，提高CPU的使用率。但协作式调度不够智能的时候，会白白浪费CPU的执行能力，而抢占式调度可以规避这个问题。

> Q: Goroutine是如何调度的？

> A: 老版的Go语言只能依靠goroutine主动出让CPU控制权才能触发调度，而在后续的版本迭代中引入了抢占式调度，GPM模型

### GPM调度模型

* G — 表示 Goroutine，它是一个待执行的任务
* M — 表示操作系统的线程，它由操作系统的调度器调度和管理
* P — 表示处理器，它可以被看做运行在线程上的本地调度器

### CSP（communicating sequential processes）并发模型

> 使用通信来共享内存，而不是通过共享内存来通信

通过[goroutine](/golang/goroutine.md)和[channel](/golang/channel.md)来实现

