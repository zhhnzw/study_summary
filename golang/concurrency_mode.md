## 并发模型

### 并发和并行的区别
并发是**同时处理**多件事情，同一时间可以只做一件，而把其他任务做到一半先暂停，后续被暂停的任务再恢执行，这样来回切换达到并发处理多件事情的目的。并行是**同时做**多件事情，需要多核CPU支持。

### 什么是进程？

进程没被执行时，只是一个二进制文件。一旦被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。像这样一个程序运起来后的计算机执行环境的总和，就是进程。

### 进程、线程、协程的区别

**进程**：是系统资源分配的最小单位

**线程**：是CPU调度最小单位

**协程**：用户态轻量级线程，协程调度不需要内核参与而是由用户态程序来决定，协程对于操作系统而言是无感知的

* 进程之间是相互隔离的，各自拥有自己的内存空间，因此CPU对进程切换执行成本高
* 进程是线程的载体容器，进程内的多线程共享其内存空间，因此线程之间的通信比进程通信容易得多
* CPU在多线程之间快速切换调度执行，以此达到多线程并发执行的效果
* 虽然线程比较轻量，但是也有不小的调度开销，当线程开的太多，也会导致高CPU调度消耗
* 多个coroutine可以绑定在同一个线程之上，由协程调度器管理，因此coroutine的调度减少了线程频繁切换的调度开销(go程序默认只使用与CPU数量相等的线程数量)

> Q: 用户态的协程如何适时的主动出让CPU控制权？

> A: goroutine控制器可能切换的点：
>
> 1. io，select关键字
> 2. channel阻塞
> 3. 等待锁
> 4. 函数调用(有时)
> 5. runtime.Gosched()

> Q: 协作式调度和抢占式调度的优缺点？

> A: 协作式调度可以降低线程切换开销，提高CPU的使用率。但协作式调度不够智能的时候，会白白浪费CPU的执行能力，而抢占式调度可以规避这个问题。

> Q: Goroutine是如何调度的？

> A: 老版的Go语言只能依靠goroutine主动出让CPU控制权才能触发调度，而在后续的版本迭代中引入了抢占式调度，GPM模型

### CSP（communicating sequential processes）并发模型

> 使用通信来共享内存，而不是通过共享内存来通信

通过[goroutine](/golang/goroutine.md)和[channel](/golang/channel.md)来实现

#### 流水线FAN模型

![FAN-OUT和FAN-IN模式](../src/fan.png)

#### 协程池

![FAN-OUT和FAN-IN模式](../src/goroutine_pool.png)

#### 合理退出并发协程

* 使用`context`
* 使用`for-range`,`range`能够感知到`channel`的关闭，当`channel`被close，range就会结束
* 使用`for-select`和`,ok`，继续读closed的`channel`，`ok`的值会是`false`, 此时置`channel`为`nil`，`select`不会在`nil`的通道上进行等待
* 使用退出通道退出。定义一个`stopCh`,发送退出信号，监听方式: `case <-stopCh`，这样只需要发送1条消息，每个worker都会收到信号，进而关闭

[参考资料](https://segmentfault.com/a/1190000017251049)

### GPM调度模型
* G — 表示 Goroutine，它是一个待执行的任务
* P — 表示处理器，它可以被看做运行在线程上的本地调度器
* M — 当前操作系统分配到当前Go程序的内核线程数，它由操作系统的调度器调度和管理

#### 调度器的设计策略

* 复用线程
    - work stealing
      
        当本线程无可运行的G时, 全局G队列也为空时，尝试从其他线程绑定的P偷取G, 而不是销毁线程。
    - hand off 
    
        当本线程的G阻塞时, 线程释放绑定的P, 把P转移给其他空闲的线程执行。
        对于分离出来的阻塞的G, 由于没有与P绑定, 休眠, 随后再加入P的本地G队列去再尝试执行。
* 利用并行

    最多有GOMAXPROCS个线程分布在多个CPU上同时执行
* 抢占

    在coroutine中要等待一个协程主动让出CPU才执行下一个协程, 在GO中, 一个Goroutine最多占用CPU 10ms, 就会被其他Goroutine抢占, 防止其他Goroutine饿死。
* 全局G队列

    当P的本地G队列为空时, 它可以从全局G队列获取G。
![Goroutine调度原理](../src/GPM.png)

3者的简要关系是每个P拥有一个本地G队列(数组结构,256长度)，M必须和一个P关联才能运行P拥有的G。

Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。

线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。

上图中自顶向下是调度器的4个部分：

1. **全局G队列**（Global Queue）：存放等待运行的G。
2. **P的本地队列**：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3. **P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个（GOMAXPROCS默认为：操作系统CPU核心数）。
4. **M列表**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

[参考资料](https://lessisbetter.site/subject/)

### GPM调度过程

#### M0

启动程序后的编号为0的主线程，**全局唯一**，负责执行初始化操作和启动第一个G，即main的goroutine，启动第一个G之后，M0的功能就和其他普通M一样了。

#### G0

**不是全局唯一**，每个M在启动时，都会先创建它对应的G0，G0本身不指向任何可执行函数，G0仅用于负责调度G。比如G2切换到G3的具体过程是：G2切换到G0，G0切换到G3，G的切换需要依赖G0。

#### 以helloworld为例的简单程序的调度过程

进程刚刚启动，还没执行到main函数时，创建M0，M0创建G0，全局G队列初始化，P列表初始化。

![Goroutine调度原理](../src/golang/concurrency/hello_world_0.png)

此时，程序执行到main函数，M0创建除G0外的第一个G，即main的goroutine。

![Goroutine调度原理](../src/golang/concurrency/hello_world_1.png)

创建main G之后，M0与G0解绑，并寻找一个空闲的P与它绑定，随后把main G放入P的本地队列中（此时没有G与M0绑定）。

![Goroutine调度原理](../src/golang/concurrency/hello_world_2.png)

main G放入P的本地队列之后，其调度方式就与普通的G是一样的了，从P的本地队列取出G与M绑定，执行，若超过10ms，就放回P队列，再取出下一个G与M绑定执行，如此循环，直到main G的函数全部执行完exit或发生panic为止。

![Goroutine调度原理](../src/golang/concurrency/hello_world_3.png)

#### 场景：创建新的G



#### 场景：某个G执行完毕

#### 场景：开辟过多的G

#### 场景：唤醒正在休眠的M

#### 场景：被唤醒的M从全局G队列取G

#### 场景：从其他P队列偷取G

#### 场景：G发生调用阻塞

#### 场景：G从阻塞状态恢复

### goroutine的使用注意事项

子goroutine的panic会引起整个进程crash, 所以需要在goroutine函数写上defer recover, 注意recover只在defer语句生效

