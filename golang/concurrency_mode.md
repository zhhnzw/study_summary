## 并发模型

### 并发和并行的区别
并发是**同时处理**多件事情，同一时间可以只做一件，而把其他任务做到一半先暂停，后续被暂停的任务再恢执行，这样来回切换达到并发处理多件事情的目的。并行是**同时做**多件事情，需要多核CPU支持。

### 进程、线程、协程的区别

**进程**：是系统资源分配的最小单位

**线程**：是CPU调度最小单位

**协程**：用户态轻量级线程，协程调度不需要内核参与而是由用户态程序来决定，协程对于操作系统而言是无感知的，协作式调度

* 进程之间是相互隔离的，各自拥有自己的内存空间
* 进程是线程的载体容器，进程内的多线程共享其内存空间，因此线程之间的通信比进程通信容易得多
* 虽然线程比较轻量，但是也有不小的调度开销，而多个goroutine可以运行在同一个线程之上，因此goroutine的调度减少了线程频繁切换的调度开销(go程序默认只使用与CPU数量相等的线程数量)

> Q: 用户态的协程如何适时的主动出让CPU控制权？

> A: goroutine控制器可能切换的点：
>
> 1. io，select关键字
> 2. channel
> 3. 等待锁
> 4. 函数调用(有时)
> 5. runtime.Gosched()

> Q: 协作式调度和抢占式调度的优缺点？

> A: 协作式调度可以降低线程切换开销，提高CPU的使用率。但协作式调度不够智能的时候，会白白浪费CPU的执行能力，而抢占式调度可以规避这个问题。

> Q: Goroutine是如何调度的？

> A: 老版的Go语言只能依靠goroutine主动出让CPU控制权才能触发调度，而在后续的版本迭代中引入了抢占式调度，GPM模型

### CSP（communicating sequential processes）并发模型

> 使用通信来共享内存，而不是通过共享内存来通信

通过[goroutine](/golang/goroutine.md)和[channel](/golang/channel.md)来实现

#### 流水线FAN模型

![FAN-OUT和FAN-IN模式](../src/fan.png)

#### 协程池

![FAN-OUT和FAN-IN模式](../src/goroutine_pool.png)

#### 合理退出并发协程

* 使用`context`
* 使用`for-range`,`range`能够感知到`channel`的关闭，当`channel`被close，range就会结束
* 使用`for-select`和`,ok`，继续读closed的`channel`，`ok`的值会是`false`, 此时置`channel`为`nil`，`select`不会在`nil`的通道上进行等待
* 使用退出通道退出。定义一个`stopCh`,发送退出信号，监听方式: `case <-stopCh`，这样只需要发送1条消息，每个worker都会收到信号，进而关闭

[参考资料](https://segmentfault.com/a/1190000017251049)

### GPM调度模型
* G — 表示 Goroutine，它是一个待执行的任务
* P — 表示处理器，它可以被看做运行在线程上的本地调度器
* M — 表示操作系统的线程，它由操作系统的调度器调度和管理

####调度器的设计策略

* 复用线程
    - work stealing
      
        当本线程无可运行的G时, 全局G队列也为空时，尝试从其他线程绑定的P偷取G, 而不是销毁线程。
    - hand off 
    
        当本线程的G阻塞时, 线程释放绑定的P, 把P转移给其他空闲的线程执行。
        对于分离出来的阻塞的G, 由于没有与P绑定, 休眠, 随后再加入P的本地G队列去再尝试执行。
* 利用并行

    最多有GOMAXPROCS个线程分布在多个CPU上同时执行
* 抢占

    在coroutine中要等待一个协程主动让出CPU才执行下一个协程, 在GO中, 一个Goroutine最多占用CPU 10ms, 就会被其他Goroutine抢占, 防止其他Goroutine饿死。
* 全局G队列

    当P的本地G队列为空时, 它可以从全局G队列获取G。
![Goroutine调度原理](../src/GPM.png)

3者的简要关系是每个P拥有一个本地G队列(数组结构,256长度)，M必须和一个P关联才能运行P拥有的G。

Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。

线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。

上图中自顶向下是调度器的4个部分：

1. **全局队列**（Global Queue）：存放等待运行的G。
2. **P的本地队列**：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3. **P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个。
4. **M**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

[参考资料](https://lessisbetter.site/subject/)