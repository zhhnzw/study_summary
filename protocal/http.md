## HTTP

### 报文组成

**请求报文:** 请求方法+请求URL+HTTP协议版本, 如:

> ```http
> GET / HTTP/1.1
> User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
> Accept: */*
> ```

**响应报文: ** HTTP协议版本+状态码+状态描述, 如:

> ```http
> HTTP/1.0 200 OK 
> Content-Type: text/plain
> Content-Length: 137582
> Expires: Thu, 05 Dec 1997 16:00:00 GMT
> Last-Modified: Wed, 5 August 1996 15:55:28 GMT
> Server: Apache 0.84
> 
> <html>
>   <body>Hello World</body>
> </html>
> ```

### Header

**请求Header**

* Content-Type: 声明客户端自己可以接受哪些数据格式. 如: application/x-www-form-urlencoded ; charset=UTF-8
* Accept: 声明客户端可以接受哪些数据格式, 如 `*/*`
* Connection: HTTP/1.1默认即持久连接, 但为了兼容HTTP老版本, 需要指定Connection: keep-alive(不同的请求复用同一个TCP连接, 降低通信开销)。客户端还可以在最后一个请求时发送Connection:close, 要求服务器关闭TCP连接
* Cookie: HTTP是无状态的。当需要完成有关联性的操作时，解决方案即是在请求和响应报文中携带Cookie来控制客户端的状态

**响应Header**

* Content-Length: HTTP 1.1有管道机制, 在同一个TCP连接里, 客户端可以同时发送多个请求，然后服务器按照顺序回应请求. 此时一个TCP连接就可以传送多个回应, 响应头声明Content-Length: 3495 就是告诉浏览器本次回应的数据长度是3495个字节，后面的字节就属于下一个回应了
* Transfer-Encoding: chunked 使用`Content-Length`字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。
* Cache-Control
* Expires
* Last-Modified

**关于压缩的Header**

* 客户端请求设置 Accept-Encoding: gzip, deflate 表明客户端能接受的数据压缩方式

* 服务端响应设置 Content-Encoding: gzip 表明服务端采取的数据压缩方式

注: 压缩的是body部分，header并没有压缩

** 关于缓存的Header **

[参考](https://juejin.im/post/5df82f77518825124953ee81)

[参考](https://www.cnblogs.com/echolun/p/9419517.html)

**关于跨域的Header**

跨域的解决方案: CORS

客户端的请求头携带`Origin`字段，表明本次请求来自哪个源(协议+域名+端口)

服务端根据请求的`Origin`字段决定是否同意这次请求(golang的gin框架下cors组件, 设置好AllowOrigins即可)

执行机制: 如果请求的`Origin`指定的域名在服务端许可范围内, 则服务端的响应头会给出`Access-Control-Allow-Origin`, 表示服务端可接受的Origin(即cors组件中设置的AllowOrigins) , 还会给出`Access-Control-Allow-Credentials`, 表示是否允许发送`Cookie`

### GET 和 POST 的区别

* 含义不同。GET方法的含义是请求从服务器获取资源，POST是向服务器提交数据，数据在报文的body里
* GET会被网络上的各种中间节点(如CDN)缓存, 而POST则不会 
* 经典误区:"GET请求的url有字符长度限制", 实际上HTTP协议本身对URL长度并没有做任何规定, 是浏览器做了这个限制
* 经典误区:"POST比GET安全". 实际上，就算私密数据放在body里, 也是可以被记录被篡改的, 因此, 安全的重要手段之一是https, 而与请求是GET还是POST关系不大。另一种说法是：GET 方法是安全且幂等的，而POST因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的(当然, 根据具体情况POST也可以实现成幂等的)。

注: 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

### 细节: POST产生2个TCP数据包?

"POST产生2个TCP数据包"也属于误区

实际上先发header后发body也不是HTTP协议对POST的规定，不是POST独有

以服务端为例的实现细节, 会先解析请求头, 再解析请求体. 比如POST在文件传输场景. 首先只解析请求头, 查看用户是不是有权限,文件名是不是符合规范等. 如果不符合, 就不再处理请求体的数据了, 直接丢弃. 而不用等到整个请求都处理完了再拒绝

### 细节: 管道网络传输

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。

### 细节: 队头堵塞

当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，其后面排队的所有请求都会被阻塞

### 总结: HTTP/1.1 性能瓶颈

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

### HTTP/2

* 头信息压缩: 如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。(实现细节: 在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了)
* 二进制协议: HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制。
* 多路复用: HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。
* 数据流: HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。数据流发送到一半的时候，客户端和服务器都可以发送信号（`RST_STREAM`帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。
* 服务器推送: HTTP/2 允许服务器未经请求，主动向客户端发送资源. 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

### HTTPS

HTTPS 是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，在TCP三次握手后，还需要进行 SSL/TLS 的握手过程，其他协议内容完全一样

另外，HTTP的默认端口是80，HTTPS是443

[参考文献: 阮一峰](http://www.ruanyifeng.com/blog/2016/08/http.html)

[参考文献: 小林coding](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247483971&idx=1&sn=8f2d5dae3d95efc446061b352c8e9961&chksm=f98e46e9cef9cfff1f6bee1974b8dc27dcc42f0627dcf8ff0c0df8dbaa7a1f74587e3fafc167&scene=158#rd)