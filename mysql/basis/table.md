## 建表

### 第一范式

确保列唯一，不可再分

如：地址字段的设计，只设计1个字段就不方便查询省、市，拆分为：省、市、详细地址就满足了1NF。

但满足1NF还是有问题，如下：

| 学号id  | 学生姓名 | 系名   | 系主任 | 课名 | 分数 |
| ------- | -------- | ------ | ------ | ---- | ---- |
| 2021001 | 小明     | 计算机 | 小花   | 数学 | 70   |
| 2021001 | 小明     | 计算机 | 小花   | 英语 | 60   |

数据冗余：相同的字段信息重复的存储了多次，比如学生姓名、系。修改的时候也要对应修改这多条记录。

插入异常：如果要新建一个系，而此时这个系还没有学生，那么就会产生问题（学号id，NOT NULL）

删除异常：如果要把某个系的学生都清空（不想删系），但是记录删除之后，在该表中就查不到该系了。

### 第二范式

判断是否符合2NF，就是看数据表中是否存在非主属性对于码的部分函数依赖。若存在则数据表最高只符合1NF要求，若不存在，则符合2NF的要求。

码：如上表中的（学号id，课名）就是该表的码，因为学号id可以确定学生姓名、系名、系主任，但还不可以确定分数，再结合课名才可以确定该学生某课程的分数。

主属性：码中的字段就是主属性，如上表的学号id，课名。

非主属性：码以外的字段。

完全函数依赖：如分数依赖于（学号id，课名）。

部分函数依赖：如学生姓名只依赖于学号id。

很显然，上表中存在了对于码的部分函数依赖，所以只满足了1NF。

| 学号id | 课名 | 分数 |
| ------- | ---- | ---- |
| 2021001 | 数学 | 70   |
| 2021001 | 英语 | 60   |

| 学号id  | 学生姓名 | 系名   | 系主任 |
| ------- | -------- | ------ | ------ |
| 2021001 | 小明     | 计算机 | 小花   |
| 2021001 | 小明     | 计算机 | 小花   |

拆分之后，第一张表的码是（学号id，课名），非主属性是分数，显然分数依赖于（学号id，课名），满足2NF。第二张表的码是（学号id），显然其他3个非主属性依赖于学号id，故也满足了2NF。

2NF虽然减少了数据冗余，但与1NF一样仍然存在插入和删除异常。

### 第三范式

如果存在非主属性对于码的传递依赖，则不满足3NF。

如上表中：系主任依赖于系名，系名依赖于学号id，那么系主任就传递依赖于学号id，不满足3NF。

| 学号id  | 课名 | 分数 |
| ------- | ---- | ---- |
| 2021001 | 数学 | 70   |
| 2021001 | 英语 | 60   |

| 学号id  | 姓名 | 系名   |
| ------- | ---- | ------ |
| 2021001 | 小明 | 计算机 |
| 2021001 | 小明 | 计算机 |

| 系名   | 系主任 |
| ------ | ------ |
| 计算机 | 小花   |
| 计算机 | 小花   |

拆分之后，系变成一个单独的表了，就可以单独的改动系的信息或者学生的信息，不再存在插入和删除异常了。

### BC范式

BC范式在 3NF 的基础上，消除主属性对于码的传递依赖。 

若： 某公司有若干个仓库； 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作； 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。 

**函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量 
码：（管理员，物品名），（仓库名，物品名） 
主属性：仓库名、管理员、物品名 
非主属性：数量** 

**∵ 不存在非主属性对码的部分函数依赖和传递函数依赖**。∴ 此关系模式属于3NF。

| 仓库名 | 管理员 | 物品名    | 数量 |
| ------ | ------ | --------- | ---- |
| 上海仓 | 小明   | iPhone 12 | 30   |
| 上海仓 | 小明   | iPad Air  | 40   |

好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作： 
先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。 
某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。 
如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。 
从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。

| 仓库名 | 管理员 |
| ------ | ------ |
| 上海仓 | 小明   |
| 上海仓 | 小明   |

| 仓库名 | 物品名    | 数量 |
| ------ | --------- | ---- |
| 上海仓 | iPhone 12 | 30   |
| 上海仓 | iPad Air  | 40   |

解决办法就是要在 3NF 的基础上消除主属性对于码的传递依赖。

### 到底应该如何设计表呢？

不需要考虑各种范式的定义。按对象划分就好了，学生的属性归学生，系的属性归系，教师的属性归教师，学校的属性归学校。

### 在设计数据表时都要满足各种范式？

每个非关键字列都独立于其他非关键字列，并依赖于关键字，第三范式指数据库中不能存在传递函数依赖关系。

基本上一个设计良好的数据库表，应该就是如此的。凡是不是这样的表，在使用的时候会特别的别扭。但也有例外：

1. 快照场景：交易场景大部分是数据快照，而不是冗余，用户下单时候的用户名、地址、商品名称、商品描述等，若采用关联，商品在下单后发生了更新的话再去关联查询就会导致和用户操作时的数据不一致，从而产生纠纷。
2. 冗余场景：一般数据改动的可能性少，而查询多的场景会使用冗余，例如淘宝的店铺名称，淘宝商家中心会有这个字段，可能里面的商家论坛也有，再假设聚划算这种独立的大业务自己也存一份，再来个垂直频道电器城的后台管理也独立存一份，这种场景是由于对查询性能要求高产生的，所以必须要冗余，在业务的取舍上，肯定是对让用户更快看到信息，那么不可避免的是带来维护成本的增加，对于数据一致性问题，只要做到最终一致就可以了，分布式的CAP原则的实际应用基本都是通过牺牲数据一致性(C)来保证高可用(A)和高可靠(P)， 因为这种场景大部分都是可以接受短暂的数据不一致的，对业务的影响及其微小。