## 索引原理

### 引入问题

```sql
---建表
create table t_emp(id int primary key,name varchar(20),age int);

--插入数据
insert into t_emp values(5,'d',22);
insert into t_emp values(6,'d',22);
insert into t_emp values(7,'e',21);
insert into t_emp values(1,'a',23);
insert into t_emp values(2,'b',26);
insert into t_emp values(3,'c',27);
insert into t_emp values(4,'a',32);
insert into t_emp values(8,'f',53);
insert into t_emp values(9,'v',13);

--查询
select * from t_emp;
```

#### 为什么上面数据明明没有按顺序插入,为什么查询时却是有顺序呢?

原因是mysql底层为主键自动创建索引，会对索引进行排序。

#### 为什么要排序呢?

因为排序之后再查询就相对比较快了，如查询 id=3，我只需要按照顺序找到3就行了，如果没有排序，那么就是大海捞针，全靠运气。

### 索引为什么选用B+树来实现？

#### B树

<img src="../../src/mysql/btree.png" alt="B树" />

#### B+树

<img src="../../src/mysql/b+tree.png" alt="B+树" />

#### B+树与索引

1. B+树的磁盘读写代价更低：B+树的非叶子节点没有数据指针，占用空间小，用更少的磁盘空间就可以容纳，这样就减少了IO读写次数。

2. B+树的查询效率更加稳定：由于B+树的数据指针都存在叶子节点上，所以从根结点到叶子结点的查询路径长度相同，导致每一个数据的查询效率相当。

3. B+树可以做到对数值区间范围内的快速查找：

   B+树最下层的叶子节点是串起来的双向链表，而且是有序的。

   B+树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。

   因此，B+树支持两种查找运算：一种是按叶子节点的链表顺序查找，另一种是从根节点开始进行随机查找。

   那么在做区间范围的查找时，定位到范围查找的起始节点之后，就可以顺着链表把需要的数据都查出来。
   
4. 用B+树实现索引的树高度更低：

   每一个页的存储空间是有限的（InnoDB存储引擎中页的大小为16KB），如果非叶子节点存储data数据，将会导致每个节点（即一个页）能存储的节点的数量更小，当存储的数据量很大时，而用B树来实现索引时，树的深度将会更大，查询时的磁盘I/O次数会更多，进而影响查询效率。

<img src="../../src/mysql/index_b+tree.png" alt="B+树与索引" />

### 聚簇索引和非聚簇索引的区别？

**聚簇索引**的叶子节点就是数据节点，而**非聚簇索引**的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

**聚簇索引的顺序就是数据的物理存储顺序，而非聚簇索引与数据物理排列顺序无关。**

使用聚簇索引查找数据几乎总是比使用非聚簇索引快，因为一旦具有第一个索引值的记录被找到，具有连续索引值的记录也一定物理地紧跟其后。一张表只能有一个聚簇索引，所以非常珍贵，必须慎重设置，一般要根据这个表最常用的SQL查询方式选择某个（或多个）字段作为聚簇索引（或复合聚簇索引）。

聚簇索引默认是主键，如果表中没有定义主键，InnoDB会选择一个**唯一的非空索引**代替（“唯一的非空索引”是指列不能出现null值的唯一索引，跟主键性质一样）。如果没有这样的索引，InnoDB会隐式地定义一个主键来作为聚簇索引。

### 是如何通过索引来查找数据的？

1. InnoDB

   <img src="../../src/mysql/innodb_index.jpg" alt="innodb通过索引查找数据" />

- 在innodb中，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找。
- InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。
- 若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）
2. MYISAM

   <img src="../../src/mysql/mysiam_index.jpg" alt="MyISAM通过索引查找数据" />

- MyISAM使用的是非聚簇索引，**非聚簇索引的两棵B+树看上去没什么不同**，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于**索引树是独立的，通过辅助键检索无需访问主键的索引树**。

注：由上可知，一个索引对应一棵B+树。

### 使用聚簇索引的优势

问题: 每次使用辅助索引检索都要经过两次B+树查找，看上去聚簇索引的效率明显要低于非聚簇索引，这不是多此一举吗？聚簇索引的优势在哪？

- 1.由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中（缓存器），再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

- 2.辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。

### 为什么主键通常建议使用自增id？

聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id（比如使用uuid），那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。 

